const { ethers } = require("ethers");
const fs = require("fs");
const path = require("path");

async function main() {
    // Connect to Ganache (default: http://127.0.0.1:8545)
    const provider = new ethers.JsonRpcProvider("http://127.0.0.1:8545");
    const signer = await provider.getSigner();

    console.log("Connected to Ganache with signer:", await signer.getAddress());

    // Compile the contract (assuming solc is available in the environment)
    // For a more robust solution, use a build system like Hardhat or Truffle
    const contractPath = path.resolve(__dirname, "..", "contracts", "PokemonNFT.sol");
    
    // Read ABI and bytecode from files generated by solc
    const abi = JSON.parse(fs.readFileSync(path.resolve(__dirname, "..", "PokemonNFT.abi"), "utf8"));
    const bytecode = "0x" + fs.readFileSync(path.resolve(__dirname, "..", "PokemonNFT.bin"), "utf8");


    // Create a contract factory
    const PokemonNFT = new ethers.ContractFactory(abi, bytecode, signer);

    console.log("Deploying PokemonNFT...");
    const pokemonNFT = await PokemonNFT.deploy("PokemonNFT", "PNFT");
    await pokemonNFT.waitForDeployment();

    console.log("PokemonNFT deployed to:", await pokemonNFT.getAddress());

    // Save deployed contract address to a file for frontend to use
    fs.writeFileSync(
        path.resolve(__dirname, "contract-address.json"),
        JSON.stringify({ PokemonNFT: await pokemonNFT.getAddress() }, undefined, 2)
    );
    console.log("Deployed contract address saved to deploy/contract-address.json");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });