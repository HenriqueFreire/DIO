Construindo Imagens Docker de Próxima Geração com NixIntroduçãoNo fluxo tradicional de DevOps, o Dockerfile é o padrão. No entanto, ele sofre com problemas de reprodutibilidade (o comando apt-get update hoje pode trazer pacotes diferentes de amanhã) e camadas desnecessariamente grandes.O Nix transforma a criação de imagens Docker em uma função puramente matemática: os mesmos inputs sempre gerarão a mesma imagem, bit a bit.1. Por que Nix em vez de Dockerfile?Diferente de uma receita sequencial de comandos, o Nix utiliza derivações.Imutabilidade: Cada pacote reside em um caminho único baseado no seu hash (ex: /nix/store/v9p...-nodejs-20.x).Zero Lixo: A imagem final contém apenas o executável e suas dependências exatas. Sem gerenciadores de pacotes (apt, apk), sem shell (opcional) e sem arquivos temporários.Cache Inteligente: Se você alterar uma linha de código, o Nix não precisa baixar as dependências novamente; ele reutiliza o que já está no Nix Store.2. Ferramentas e EcossistemasPara que o Nix interaja com projetos existentes, ele utiliza diferentes abordagens dependendo da linguagem.LinguagemFerramenta / Função NixArquivo de OrigemEstratégia NixGobuildGoModulego.modNativa: O suporte ao Go está embutido no Nixpkgs.C++stdenv.mkDerivationCMake/MakeNativa: O Nix atua como o próprio gerenciador de dependências.JavaScriptnapalm / node2nixpackage-lock.jsonConversor: Traduz o ecossistema NPM para o Nix.Rustnaersk / craneCargo.lockConversor: Traduz o Cargo para derivações Nix.Javagradle2nixbuild.gradleConversor: Mapeia dependências Gradle/Maven.3. Entendendo o suporte Nativo (Go e C++)Diferente de linguagens como Node.js ou Python, que exigem ferramentas externas para "traduzir" suas dependências para o Nix, o suporte para Go e C++ é integrado organicamente ao ecossistema Nix.Go: Suporte EmbutidoNo caso do Go, o Nix já possui funções de alto nível como buildGoModule. Você não precisa de um "go2nix", pois o Nix consegue ler o arquivo go.mod diretamente. Ele lida com o isolamento do diretório vendor e garante que a compilação seja feita em uma sandbox sem acesso à rede, utilizando apenas os hashes declarados.C++: O Nix como Gerenciador de DependênciasC++ é conhecido por não possuir um gerenciador de dependências universal e padronizado. O Nix resolve isso assumindo esse papel. Em vez de instalar bibliotecas no sistema (em /usr/lib), você declara suas dependências (como boost, openssl ou zlib) diretamente na expressão Nix. O Nix fornece o ambiente de compilação com os headers e as bibliotecas já vinculadas de forma determinística, eliminando o clássico erro de "library not found".4. Como Gerar a Imagem DockerO fluxo de trabalho substitui o docker build tradicional por um processo de derivação:Build: Execute nix-build docker.nix. Isso gera um arquivo result (um tarball da imagem).Load: Importe para o Docker local: docker load < result.Run: O container estará pronto para execução imediata: docker run nix-app:latest.5. Conclusão: Segurança e EficiênciaAo remover o que é desnecessário (como compiladores e shells) e fixar as versões das dependências pelo hash, você reduz drasticamente a superfície de ataque para CVEs. O uso do Nix permite que você saia de um modelo de "tentativa e erro" com camadas de Dockerfile para uma verdadeira Engenharia de Software Aplicada à Infraestrutura.